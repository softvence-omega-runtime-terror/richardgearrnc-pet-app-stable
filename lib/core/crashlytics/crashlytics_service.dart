import 'dart:async';

import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:petzy_app/config/env_config.dart';
import 'package:petzy_app/core/utils/logger.dart';
import 'package:petzy_app/firebase_options.dart';

part 'crashlytics_service.g.dart';

/// Service for crash reporting using Firebase Crashlytics.
///
/// ## Setup Required:
///
/// 1. Create a Firebase project at https://console.firebase.google.com
/// 2. Add your Android and iOS apps to the Firebase project
/// 3. Download and add the configuration files:
///    - Android: `google-services.json` to `android/app/`
///    - iOS: `GoogleService-Info.plist` to `ios/Runner/`
/// 4. Run `flutterfire configure` to generate `firebase_options.dart`
///
/// ## Usage:
///
/// ```dart
/// // Record a non-fatal error
/// ref.read(crashlyticsServiceProvider).recordError(
///   exception,
///   stackTrace,
///   reason: 'API call failed',
/// );
///
/// // Log a message (appears in crash reports as breadcrumbs)
/// ref.read(crashlyticsServiceProvider).log('User tapped checkout button');
///
/// // Set user identifier for crash reports
/// ref.read(crashlyticsServiceProvider).setUserId('user_123');
///
/// // Set custom keys for debugging
/// ref.read(crashlyticsServiceProvider).setCustomKey('screen', 'checkout');
/// ```
///
/// ## Features:
/// - Automatic crash reporting (fatal errors)
/// - Manual error recording (non-fatal errors)
/// - Custom log messages as breadcrumbs
/// - User identification
/// - Custom key-value pairs for debugging
/// - Respects user privacy (can be disabled)
@Riverpod(keepAlive: true)
CrashlyticsService crashlyticsService(final Ref ref) {
  return CrashlyticsService(ref);
}

/// Firebase Crashlytics wrapper service.
class CrashlyticsService {
  /// Creates a [CrashlyticsService] instance.
  CrashlyticsService(this._ref);

  final Ref _ref;
  FirebaseCrashlytics? _crashlytics;

  AppLogger get _logger => _ref.read(loggerProvider);

  /// Whether Crashlytics is enabled.
  /// Disabled in debug mode and for dev environment by default.
  bool get isEnabled => !kDebugMode && EnvConfig.isProd && _crashlytics != null;

  /// Initialize Firebase and Crashlytics.
  ///
  /// Call this in [AppBootstrap.initialize] before runApp().
  /// Requires `firebase_options.dart` generated by `flutterfire configure`.
  ///
  /// Example:
  /// ```dart
  /// await CrashlyticsService.initialize();
  /// ```
  static Future<void> initialize({
    final bool enableInDebug = false,
    required final Environment environment,
  }) async {
    try {
      // Initialize Firebase with platform-specific options
      // Generated by: flutterfire configure
      if (Firebase.apps.isEmpty) {
        await Firebase.initializeApp(
          options: DefaultFirebaseOptions.currentPlatform,
        );
      }

      final crashlytics = FirebaseCrashlytics.instance;

      // Enable/disable based on environment
      final shouldEnable = enableInDebug || (!kDebugMode && EnvConfig.isProd);
      await crashlytics.setCrashlyticsCollectionEnabled(shouldEnable);

      if (shouldEnable) {
        // Pass Flutter errors to Crashlytics
        FlutterError.onError = (final details) {
          // Still present the error in debug mode
          FlutterError.presentError(details);
          // Record to Crashlytics
          crashlytics.recordFlutterFatalError(details);
        };

        // Pass async errors to Crashlytics
        PlatformDispatcher.instance.onError = (final error, final stack) {
          crashlytics.recordError(error, stack, fatal: true);
          return true;
        };
      }

      AppLogger.instance.i(
        'Crashlytics initialized (enabled: $shouldEnable)',
      );
    } catch (e, stack) {
      // Don't crash the app if Crashlytics fails to initialize
      AppLogger.instance.e(
        'Failed to initialize Crashlytics',
        error: e,
        stackTrace: stack,
      );
    }
  }

  /// Record a non-fatal error.
  ///
  /// Use this for errors that don't crash the app but should be tracked.
  Future<void> recordError(
    final dynamic exception,
    final StackTrace? stackTrace, {
    final String? reason,
    final bool fatal = false,
    final Iterable<Object>? information,
  }) async {
    if (!isEnabled) {
      _logger.d('Crashlytics disabled, logging error locally: $exception');
      return;
    }

    try {
      await _crashlytics!.recordError(
        exception,
        stackTrace,
        reason: reason,
        fatal: fatal,
        information: information ?? const [],
      );
    } catch (e) {
      _logger.e('Failed to record error to Crashlytics', error: e);
    }
  }

  /// Record a Flutter error.
  Future<void> recordFlutterError(
    final FlutterErrorDetails details, {
    final bool fatal = false,
  }) async {
    if (!isEnabled) {
      _logger.d('Crashlytics disabled, logging Flutter error locally');
      return;
    }

    try {
      if (fatal) {
        await _crashlytics!.recordFlutterFatalError(details);
      } else {
        await _crashlytics!.recordFlutterError(details);
      }
    } catch (e) {
      _logger.e('Failed to record Flutter error to Crashlytics', error: e);
    }
  }

  /// Log a message that will appear in crash reports as breadcrumbs.
  ///
  /// Use this to track user actions leading up to a crash.
  Future<void> log(final String message) async {
    if (!isEnabled) return;

    try {
      await _crashlytics!.log(message);
    } catch (e) {
      _logger.e('Failed to log to Crashlytics', error: e);
    }
  }

  /// Set the user identifier for crash reports.
  ///
  /// This helps identify crashes from specific users.
  /// Use a hashed/anonymized identifier if possible.
  Future<void> setUserId(final String identifier) async {
    if (!isEnabled) return;

    try {
      await _crashlytics!.setUserIdentifier(identifier);
    } catch (e) {
      _logger.e('Failed to set Crashlytics user ID', error: e);
    }
  }

  /// Clear the user identifier (e.g., on logout).
  Future<void> clearUserId() async {
    if (!isEnabled) return;

    try {
      await _crashlytics!.setUserIdentifier('');
    } catch (e) {
      _logger.e('Failed to clear Crashlytics user ID', error: e);
    }
  }

  /// Set a custom key-value pair for debugging.
  ///
  /// These appear in crash reports and help identify the app state.
  Future<void> setCustomKey(
    final String key,
    final Object value,
  ) async {
    if (!isEnabled) return;

    try {
      await _crashlytics!.setCustomKey(key, value);
    } catch (e) {
      _logger.e('Failed to set Crashlytics custom key', error: e);
    }
  }

  /// Check if crash reports were sent in the last session.
  Future<bool> didCrashOnPreviousExecution() async {
    if (!isEnabled) return false;

    try {
      return await _crashlytics!.didCrashOnPreviousExecution();
    } catch (e) {
      _logger.e('Failed to check previous crash', error: e);
      return false;
    }
  }

  /// Force a crash for testing purposes.
  ///
  /// **WARNING:** Only use this in development for testing!
  void testCrash() {
    if (kDebugMode) {
      _crashlytics?.crash();
    }
  }
}
